WELCOME

	Edelweiss: A decentralized compiler
	github.com/ipld/edelweiss

HISTORY BLITZ

	Decentralized data structures require a new data model.

	IPLD = decentralized JSON = JSON + content-addressable links

	Data model is agnostic to:
	- Application abstractions, above
	- Serialization, below

	Protocol stack:
	-> Application-level:
		- file formats (UnixFS, MFS, Filecoin storage, etc)
		- service interfaces (Reframe, StoreTheIndex, Filecoin actors, etc)
	- Data Model (IPLD)
	- Serialization (JSON, CBOR, etc.)

APPLICATION DEVELOPMENT NEEDS

	- Higher level data abstractions (e.g. file system, content provider, signed peer record)
	- Service interfaces (e.g. Reframe API, StoreTheIndex API, Filecoin actor API)
		- agnostic to RPC networking technology (e.g. HTTP-JSON, HTTP-CBOR, libp2p-CBOR, FVM, etc)
	- Language bindings (Go, JavaScript, Rust at minimum, but also Python, Lean, Julia, etc)

PRIOR WORK

	- Higher level data abstractions modeled using schema languages (Protobuf, XML Schema, XXX)
		- Pros:
			- Schema types expose low-level features of serialization technology (e.g. Protobuf field indices)
		- Cons: 
			- Don't map naturally to programming language type systems (e.g. XXX)
			- Serialization-specific

	- Service interfaces (e.g. Protobuf, GRPC)
		- Pros:
			- XXX
		- Cons:
			- Lack of basic "modern" and necessary abstractions like lambdas (e.g. FVM actors and EVM smart contracts)

OUR APPROACH

	Data and service definition language:
		- Higher data and service abstractions (e.g. file system state and API) are modeled as types
		- Types are composed from a standard, complete modern set of generic building blocks
			(structures, unions, lambdas, links, inductive, etc)
		- Types have IPLD representations (encode to and decode from IPLD)

	Bindings to programming languages:
		- Compiler that generates code
		- Simple, language-aware framework for writing code templates (novel)

	Developer features:
		- Compiler can check whether two types (e.g. file formats, service APIs) are interoperable
		- Compiler could generate type descriptors (not implemented)
		- Type system supports generic, dependent types (e.g. "link to a file system of CAR files")

TYPES

	- Primitive:
		Bool, Float, Int, Byte, Char, String, Bytes
		Int128, UInt256, Float64, ...
	- Special:
		Any, Nothing
	- Composite:
		Link, List, Map, Structure, Tuple, Inductive (Lean, OCaml)
	- Functional:
		Lambda, Service, Method
	- Combinatorial (Lean, OCaml, Julia):
		Singleton, Union

FINE GRAIN INTEROPERABILITY

	- SemVer is too linear for decentralized software development
	XXX

TYPES CODIFY PROTOCOL PARSING RULES

	- interoperability baked into types (union, inductive, singleton)

XXX

	- Current users: Reframe API, IPFS, DHT Hydra Booster, StoreTheIndex

	- No source syntax yet, build ASTs (planned to be a superset of IPLD schema)
	- We are hiring a compiler engineer!
